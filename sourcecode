/*
Name: Raymond, Akhil, Shrihan
Date: 6/3/25
Project Name: Maze Game/Solver
Extra: Pairs, Queues, Backtracking (BFS)
*/
#include <iostream>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <queue>
using namespace std;

pair<pair<int, int>, pair<int, int>> generateMaze(int length, vector<vector<char>>& maze) {
    for (int i = 0; i < length; i++) {
        for (int j = 0; j < length; j++) {
            maze[i][j] = (rand() % 3 == 1) ? '#' : '.'; // Ternary operator used as if statement
        }
    }
    // Creating Exit & Start Position
    int ex = rand() % length;
    int ey = rand() % length;
    int sx = rand() % length;
    int sy = rand() % length;
    while (sx == ex && sy == ey) { // Ensure start != end
        ex = rand() % length;
        ey = rand() % length;
    }
    maze[ex][ey] = 'E';
    maze[sx][sy] = 'S';
    for (int i = 0; i < length; i++) { // Printing out maze
        for (int j = 0; j < length; j++) {
            cout << maze[i][j] << ' ';
        }
        cout << "\n";
    }
    return {{sx, sy}, {ex, ey}};
}

void userSolve(int length, vector<vector<char>>& maze, pair<int, int> start, pair<int, int> end) {
    bool solved = false;
    char move;
    int sx = start.first;
    int sy = start.second;
    int ex = end.first;
    int ey = end.second;
    int moves = 0;
    while (!solved) { // Goes until user solves the maze or gives up
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                cout << maze[i][j] << ' ';
            }
            cout << "\n";
        }
        cout << "Where would you like to move? (Use WASD to move. W = Up, A = Left, S = Down, D = Right. Type in the corresponding character. If you would like to give up, type E) ";
        cin >> move;
        int tempx = sx;
        int tempy = sy;
        if (move == 'W') {
            sx -= 1;
        }
        else if (move == 'A') {
            sy -= 1;
        }
        else if (move == 'S') {
            sx += 1;
        }
        else if (move == 'D') {
            sy += 1;
        }
        else if (move == 'E') {
            break;
        }
        if (sx < length & sy < length & sx >= 0 & sy >= 0 & (maze[sx][sy] == '.' || maze[sx][sy] == 'E')) {
            maze[sx][sy] = '+';
            moves++;
            if (maze[tempx][tempy] == '.') {
                maze[tempx][tempy] = '.';
            }
            if (maze[sx][sy] == 'E') {
                cout << "Congratulations, you have found a solution! It took you " << moves << " moves." << endl;
                break;
            }
        }
        else {
            cout << "Invalid move." << endl;
            sx = tempx;
            sy = tempy;
        }
    }
}

void solveMaze(int length, vector<vector<char>>& maze, pair<int, int> start, pair<int, int> end) {
    vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    queue<pair<int, int>> q; // Initializes a queue
    vector<vector<bool>> visited(length, vector<bool>(length, false));
    vector<vector<pair<int, int>>> before(length, vector<pair<int, int>>(length, make_pair(-1, -1))); // Creates a 2D vector that has inner vectors containing pairs of integers (each pair is initialized to -1, -1)
    int sx = start.first;
    int sy = start.second;
    int ex = end.first;
    int ey = end.second;
    q.push(make_pair(sx, sy));
    visited[sx][sy] = true;
    bool fnd = false;
    while (!q.empty() && !fnd) {
        pair<int, int> crnt = q.front();
        q.pop();
        int x = crnt.first;
        int y = crnt.second;
        
        for (int i = 0; i < dirs.size(); i++) {
            int dx = dirs[i].first;
            int dy = dirs[i].second;
            int nx = x + dx; // Tries moving in the current direction
            int ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < length && ny < length &&
                !visited[nx][ny] && (maze[nx][ny] == '.' || maze[nx][ny] == 'E')) {
                visited[nx][ny] = true;
                before[nx][ny] = make_pair(x, y);
                q.push(make_pair(nx, ny));
                if (nx == ex && ny == ey) { // If the new coordinates equal to the coordinates of the exit, a solution has been found
                    fnd = true;
                    break;
                }
            }
        }
    }
    if (fnd) {
        int crx = ex;
        int cry = ey;
        while(before[crx][cry] != make_pair(-1, -1)) { // Backtracking through all previously visited coordinates
            pair<int, int> prev = before[crx][cry];
            if (maze[crx][cry] != 'E') {
                maze[crx][cry] = '|'; // Marking path using lines
            }
            crx = prev.first;
            cry = prev.second;
        }
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                cout << maze[i][j] << ' ';
            }
            cout << "\n";
        }
        cout << "A solution has been found! Lines indicate the shortest path to get from S, the starting point, to E, the exit point." << endl;
    }
    else {
        cout << "No path has been found that connects S, the starting point, and E the exit point." << endl;
    }
}

int main() {
    srand(time(0));
    int length;
    char ans;
    cout << "Enter the maze length: ";
    cin >> length;
    vector<vector<char>> maze(length, vector<char>(length)); // Initializes 2D vector
    pair<pair<int, int>, pair<int, int>> pos = generateMaze(length, maze);
    pair<int, int> st = pos.first;
    pair<int, int> end = pos.second;
    cout << "Maze has been generated." << endl;
    cout << "Would you like to try and solve the maze? (y or n) ";
    cin >> ans;
    bool solved = false;
    if (ans == 'y') {
        userSolve(length, maze, st, end);
    }
    else if (ans == 'n') {
        cout << "Alright, if a solution to the maze has been found, it will now be generated." << endl;
        solveMaze(length, maze, st, end);
    }
    else {
        cout << "You did not enter a valid answer. Exiting now..." << endl;
    }
    return 0;
}
